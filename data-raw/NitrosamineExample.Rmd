---
author: "Steve Rozen"
output: html_document
date: '`r Sys.Date()`'
params:
  whichnitro: NPIP
  bgfactor: 2
  showrecon: FALSE
  showbgspec: FALSE
  onefhigh: 2.5
  verbose: FALSE
title: '`r paste("Background Subtraction for", params$whichnitro, "and Background Inflation Factor", params$bgfactor)`'  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# params <- list(whichnitro = "NPYR", bgfactor = 16)
```
### Introduction

This is an example of background subtraction using the mSigAct package.

In this example we subtract the background signature of
HepG2 cells from the nitrosamine `r params$whichnitro`.

Here we are testing with an artificially increased estimate of the
level of background signature by a factor of `r params$bgfactor`.

### Libraries, graphics parameters, and helper functions


```{r, libraries, echo=params$verbose}
library(mSigAct)
library(ICAMS)
```

```{r, utilties, echo=params$verbose}
in.ranges <- list(NDEA = 1:2,
                  NDMA = 3:4,
                  NPIP = 5:6,
                  NPYR = 7:8)
```

```{r, util_func, echo=params$verbose}

spectra <- # The input spectra for one nitrosamine
  mSigAct::nitrosamine.examples$catSBS96[ , in.ranges[[params$whichnitro]]]

set.initial.par <- function(catalog) {
  par(pin = c(5, 1))
  par(mfrow = c(ncol(catalog), 1))
  par(mar = c(2, 4, 4, 2))
  par(cex = 0.8)
  par(cex.main = 1.4) 
}

last.bottom.mar <- 4.5
```

```{r, define_pcat1, echo=params$verbose}
pcat1 <- function(catalog, ylim = NULL) {
  par(pin = c(5, 1))
  par(mar = c(5, 4, 5, 4))
  par(cex = 0.8)
  par(cex.main = 1.4)
  bp <- ICAMS::PlotCatalog(catalog[ , 1, drop = FALSE],
                           upper   = TRUE,
                           xlabels = TRUE,
                           ylim    = ylim
                           )
  return(invisible(bp$plot.object))
}
```

```{r, define_pcat, echo=params$verbose}
pcat <- function(catalog) {
  set.initial.par(catalog)
  xlabels <- FALSE
  for (i in 1:ncol(catalog)) {
    if (i == ncol(catalog)) {
      xlabels <- TRUE
      par(mar = c(last.bottom.mar, 4, 3, 2))
    }
    
    ICAMS::PlotCatalog(catalog[ , i, drop = FALSE],
                       upper = (i == 1),
                       xlabels = xlabels)
  }
}
```

```{r, define_stacked_pcat, echo=params$verbose}
stacked.pcat <- function(bg.catalog, target.catalog, set.neg.zero = TRUE) {
  
  set.initial.par(bg.catalog)
  xlabels <- FALSE

  for (i in 1:ncol(bg.catalog)) {
    if (i == ncol(bg.catalog)) {
      xlabels <- TRUE
      par(mar = c(last.bottom.mar, 4, 3, 2))
    }
    
    target.cat.1 <- target.catalog[ , i, drop = FALSE]
    bg.cat.1     <- bg.catalog[ , i, drop = FALSE]    
    
    zeros <- which(target.cat.1 < 0)
    neg.catalog <- target.cat.1
    
    if (set.neg.zero) {
      target.cat.1[zeros] <- 0
    }
    neg.catalog[-zeros] <- 0
    neg.catalog <- neg.catalog * -1

    to.plot <- cbind(bg.cat.1, target.cat.1)
    
    bp <- ICAMS::PlotCatalog(
      to.plot,
      upper   = (i == 1),
      xlabels = xlabels)$plot.object
    
    bpz <- bp[zeros]
    # message(paste(bpz, collapse = " "))

    y0 <- bg.cat.1[zeros]
    y1 <- bg.cat.1[zeros] - neg.catalog[zeros]
    if (attr(target.catalog, "catalog.type") == "density") {
      # message("adjusting for density")
      y0 <- y0 * 1e6
      y1 <- y1 * 1e6
    }

    # message(paste(y0, collapse = "y"))
    # message(paste(y1, collapse = "z"))
    minus.col <- "purple"
    segments(x0 = bpz, 
             y0 = y0, 
             y1 = y1, 
             col = minus.col,
             lwd = 3,
             lty = 1)

    legend.txt <- c(params$whichnitro, "Background")
    legend.col <- c("grey35", "red")
    if (length(bpz) > 0) {
      legend.txt <- c(legend.txt, paste("Background -", params$whichnitro))
      legend.col <- c(legend.col, minus.col)
    }
    legend("topright", legend = legend.txt, fill = legend.col, cex = 0.8)
  }
}

add.arrows <- function(bp, tops, bottoms) {
  oldopt <- getOption("warn")
  on.exit(options(warn = oldopt))
  options(warn = -1)
  suppressWarnings(
    # Necessary because generates warnings for 0-length arrows
    arrows(
      x0     = bp,
      y0     = tops,    # location of up arrow tips
      y1     = bottoms, # location of down arrow tips
      angle  = 90,      # use "T" arrow heads
      code   = 3,       # use arrow heads at both ends
      length = 0.025    # width of arrow heads
    ))
}

```

### Input count spectra

```{r, plot.input.spectra}
pcat(spectra)
```

### Input density spectra

```{r input_spectra_as_density}
pcat(ICAMS::TransformCatalog(spectra, 
                             target.catalog.type = "density"))
```

### Subtract the background to infer the signature of `r params$whichnitro`

```{r subtract}
bg.info <- mSigAct::HepG2.background.info
bg.info$count.nbinom.mu <- params$bgfactor * bg.info$count.nbinom.mu

# if (params$whichnitro != "NDEA") {
if (TRUE) {
ret <- 
  FindSignatureMinusBackground(
    spectra     = spectra,
    bg.sig.info = bg.info,
    m.opts      = NULL,
    start.b.fraction = 0.5)
} else {
  load(devtools::package_file("data-raw/saved.bg.Rdata"))
}
```

```{r inferred_sig_as_catalog}
inferred.sig <- 
  ICAMS::as.catalog(
    object         = ret$inferred.target.sig, 
    catalog.type   = "counts.signature",
    region         = "genome",
    abundance      = attr(mSigAct::nitrosamine.examples$catSBS96,
                          "abundance"),
    infer.rownames = TRUE)
colnames(inferred.sig) <- paste0("Inferred-", params$whichnitro, "-sig")
```

#### Inferred `r params$whichnitro` count signature and given HepG2 background signature 

```{r, plot.inferred.spectra.signature}

two.sigs <- cbind(inferred.sig, bg.info$background.sig)
pcat(two.sigs)
```

#### Inferred `r params$whichnitro` density signature and given HepG2 background signature 


```{r, plot.inferred.density}
pcat(ICAMS::TransformCatalog(two.sigs, 
                             target.catalog.type = "density.signature"))
```


### Calculate and plot inferred components of the spectra


#### Inferred background spectra

```{r, plot.inferred.background.spectra}
total.counts <- apply(spectra, MARGIN = 2, sum)
total.counts

bg.counts <- total.counts - ret$exposures.to.target.sig
bg.counts

inferred.bg.spectra <- 
  round(bg.info$background.sig %*% matrix(bg.counts, nrow = 1))
inferred.bg.spectra <- ICAMS::as.catalog(inferred.bg.spectra,
                                         catalog.type   = "counts",
                                         region         = "genome",
                                         abundance      = attr(spectra, "abundance"),
                                         infer.rownames = TRUE)
colnames(inferred.bg.spectra) <- paste0(colnames(spectra), "-inf-bg-spect")
```
```{r, pl_inferred_bg_spec, eval=params$showbgspec, echo=params$showbgspec}
pcat(inferred.bg.spectra)
```
#### Inferred spectra due to `r params$whichnitro`

```{r, plot.inferred.target.spectra}
subtracted.target.spectra <- spectra - inferred.bg.spectra
pcat(subtracted.target.spectra)
```

#### Uncertainty in inferred signature based on variability of inferred spectra


```{r, var_infer_sig, fig.height=2.5, warning=FALSE}
sub.target.sig.ests <- 
  ICAMS::TransformCatalog(subtracted.target.spectra, 
                          target.catalog.type = "counts.signature")

arrow.tops <- apply(sub.target.sig.ests, 1, max)
arrow.bottoms <- apply(sub.target.sig.ests, 1, min)
min.sub <- min(arrow.bottoms)
min.sub
bp <- pcat1(inferred.sig, ylim = c(min.sub, max(arrow.tops) + 0.005))
add.arrows(bp, arrow.tops, arrow.bottoms)
```

```{r, dens_var_infer_sig, fig.height = 2.5, warning=FALSE}
d.sub.target.sig.ests <- 
  ICAMS::TransformCatalog(sub.target.sig.ests, 
                          target.catalog.type = "density.signature")

arrow.tops <- apply(d.sub.target.sig.ests, 1, max)
arrow.bottoms <- apply(d.sub.target.sig.ests, 1, min)
min.sub <- min(arrow.bottoms)
min.sub
bp <- pcat1(
  ICAMS::TransformCatalog(inferred.sig,
                          target.catalog.type = "density.signature"),
  ylim = c(min.sub, max(arrow.tops)  + 0.005))
add.arrows(bp, arrow.tops, arrow.bottoms)

```


#### Combined background and target spectra

```{r, plot.combined.count}
# debug(stacked.pcat)
stacked.pcat(inferred.bg.spectra, subtracted.target.spectra)
```

```{r, plot.combined.density}
stacked.pcat(
  ICAMS::TransformCatalog(inferred.bg.spectra,
                          target.catalog.type = "density"),
  ICAMS::TransformCatalog(subtracted.target.spectra,
                          target.catalog.type = "density"))

```


`r ifelse(params$showrecon, "#### Reconstruct spectra", "")`

```{r, get.reconstructed.spectra, eval=params$showrecon, echo=params$showrecon}
reconstructed.target.spectra <- 
  round(inferred.sig %*% matrix(ret$exposures.to.target.sig, nrow = 1))
reconstructed.target.spectra <- 
  ICAMS::as.catalog(
    reconstructed.target.spectra,
    catalog.type   = "counts",
    region         = "genome",
    abundance      = attr(spectra, "abundance"),
    infer.rownames = TRUE)
colnames(reconstructed.target.spectra) <-
  paste0(colnames(spectra), "-mult-recon-spect")
pcat(reconstructed.target.spectra)


total.spectra <- reconstructed.target.spectra + inferred.bg.spectra
c1 <- mSigAct:::cossim(total.spectra[ ,1], spectra[ ,1])
c2 <- mSigAct:::cossim(total.spectra[ ,2], spectra[ ,2])
dist(rbind(total.spectra[ ,1], spectra[ ,1]), method = "euclidean")
dist(rbind(total.spectra[ ,2], spectra[ ,2]), method = "euclidean")

```
`r ifelse(params$showrecon, "#### Original and reconstructed spectra side-by-side", "")`


```{r, plot.orig.and.recon, eval=params$showrecon, echo=params$showrecon}
s.by.s <- cbind(spectra[  , 1, drop = FALSE],
                total.spectra[ , 1 , drop = FALSE],
                spectra[   , 2, drop = FALSE],
                total.spectra[ , 2, drop = FALSE])
onames <- colnames(spectra)
colnames(s.by.s) <- c(
  onames[1],
  paste(onames[1], round(c1, digits = 4), sep = "-"),
  onames[2],
  paste(onames[2], round(c2, digits = 4), sep = "-")
)
```

`r ifelse(params$showrecon, paste("##### Summary of replicate 1:", colnames(spectra)[1]), "")`

```{r, plot.replicate1, eval=params$showrecon, echo=params$showrecon}
pcat(s.by.s[ , 1:2])
```

`r ifelse(params$showrecon, paste("##### Summary of replicate 2:", colnames(spectra)[2]), "")`


```{r, plot_replcate2, eval=params$showrecon, echo=params$showrecon}
pcat(s.by.s[ , 3:4])
```

